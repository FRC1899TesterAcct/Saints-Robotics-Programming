#pragma config(Sensor, in1,    fb_pot,              sensorPotentiometer)
#pragma config(Sensor, in2,    release_pot,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  encoderright,        sensorQuadEncoder) //dgt 1 and 2 will be used.
#pragma config(Sensor, dgtl3,  encoderleft,         sensorQuadEncoder) //dgt 3 and 4 will be used.
#pragma config(Motor,  port1,           backleft,      tmotorNormal, openLoop)
#pragma config(Motor,  port2,           frontleft,     tmotorNormal, openLoop)
#pragma config(Motor,  port3,           frontright,    tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           fbleft,        tmotorNormal, openLoop)
#pragma config(Motor,  port5,           fbright,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           srleft,        tmotorNormal, openLoop)
#pragma config(Motor,  port7,           srright,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port8,           release,       tmotorNormal, openLoop)
#pragma config(Motor,  port10,          backright,     tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/******************************

Xmtr2: Operator controller

5D                   6D
5U                   6U
    U             U
7 L   R         R   L 8
    D             D

Presets:

******************************/

//Drive variables

int left = 0;
int right = 0;

//Operator variables

int fourbar = 0;
int sliderail = 0;

//Release variables

int armtarget;
int armtargetstate = 3; // 0 through 3, for the different goal heights, 3 is manual control
task armpid();

//SensorValue[encoderleft] = 0;
//SensorValue[encoderright] = 0;


void pre_auton()
{

}

task autonomous()
{
  /*motor[frontleft]=25;
  motor[backleft]=25;
  motor[backright]=25;
  motor[frontright]=25;
  wait10Msec(200);
  */

}

task usercontrol()
{
	// User control code here, inside the loop

  StartTask(armpid);
  SensorValue[encoderright] = 0;
  SensorValue[encoderleft] = 0;

	while (1)
	{
	  //Drive code

	  left = vexRT[Ch3];
	  right = vexRT[Ch2];

	  motor[frontleft] = (left * abs(left))/80;
	  motor[backleft] = (left * abs(left))/80;
	  motor[frontright] = (right * abs(right))/80;
	  motor[backright] = (right * abs(right))/80;

	  //Four bar link code

	  fourbar = vexRT[Ch2Xmtr2];

	  motor[fbleft] = (fourbar * abs(fourbar))/80;
	  motor[fbright] = (fourbar * abs(fourbar))/80;

	  //Slide rail code

	  sliderail = vexRT[Ch3Xmtr2];
	  motor[srleft] = (sliderail * abs(sliderail))/80;
	  motor[srright] = (sliderail * abs(sliderail))/80;

	  /*if(SensorValue[encoderright]<450 && SensorValue[encoderleft]<450)
	  {
	    if(SensorValue[encoderleft] < SensorValue[encoderright]) //If right has run more than left
	    {
	       motor[srleft] = (sliderail * abs(sliderail))/80;
	       motor[srright] = (sliderail * abs(sliderail))/100;
	    }
	    else if(SensorValue[encoderright] < SensorValue[encoderleft]) //If left has run more than right
	    {
	       motor[srleft] = (sliderail * abs(sliderail))/100;
	       motor[srright] = (sliderail * abs(sliderail))/80;
	    }
	    else if(SensorValue[encoderright] == SensorValue[encoderleft]) //equal
	    {
	       motor[srleft] = (sliderail * abs(sliderail))/80;
	       motor[srright] = (sliderail * abs(sliderail))/80;
	    }
	  }*/

	  //Release code

	  if(vexRT[Btn6UXmtr2])
	    motor[release] = 65;
	  else if(vexRT[Btn6DXmtr2])
	    motor[release] = -65;
	  else motor[release] = 0;

	  //Four bar link presets
    /*
	  if(vexRT[Btn8UXmtr2])
	    armtargetstate = 0; //Wall goal

	  if(vexRT[Btn8RXmtr2] || vexRT[Btn8LXmtr2])
	    armtargetstate = 1; //Movable goal

	  if(vexRT[Btn8DXmtr2])
	    armtargetstate = 2; //Floor

	  if(abs(fourbar) > 20)
	    armtargetstate = 3;*/
	}
}


//***************************************************
// Pid loops
//***************************************************

task armpid()
{
    int armpotval = 0;
  	int armout = 0;
  	int armerror = 0;
  	int totalerror = 0;

  	//Pid values

  	int proportional;
  	/*int integral;
  	int derivative;*/
  	int kp = 2;
  	/*int ki = 2;
  	int kd = 2;*/

  	//Target values, insert values when measured

  	static int ground = 0;
  	static int wall_goal = 0;
  	static int movable_goal = 0;

  	while(true) {

		  armpotval = SensorValue[fb_pot]+1; // shift pot value so 0 is min

		  switch (armtargetstate)
		  {
			  case 0:
				  armtarget = 0;
				  break;
			  case 1:
				  armtarget = 150;
				  break;
			  case 2:
				  armtarget = 300;
				  break;
		   }
      /*
		  if(fourbarTarget >  || armTarget < 0) {
		  	armTarget = (armTarget > 26 ) ? 26 : 0;

		  	}*/

		    proportional = armtarget - armpotval;
		    armout = proportional * kp;

		  if(armtargetstate != 3)
		  {
	      motor[fbleft] = armout;
	      motor[fbright] = armout;
	    }
    }
}
